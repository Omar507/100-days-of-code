<html>
<head>
</head>
<body>
<script type = "text/javascript">
// YDKJS: this & Object Prototypes
// *** Chapter One ***
/*    
    function identify() {
        return this.name.toUpperCase();
    }
    
    function speak() {
        var greeting = "Hello, I'm " + identify.call(this);
        console.log(greeting);
    }
    
    var me = {
        name: "Kyle"
    };
    
    var you = {
        name: "Reader"
    };
    
    
    identify.call(me); // KYLE
    identify.call(you); // READER
    
    speak.call(me); // Hello I'm Kyle
    speak.call(you); // Hello I'm Reader
    
    
    function foo(num) {
        console.log( "foo: " + num );
        
        this.count++;
    }
    
    foo.count = 0;
    
    var i;
    
    for (i=0; i < 10; i++) {
        if (i > 5) {
            foo.call( foo, i);
        }
    }
    
    
    console.log(foo.count); //4
    
*/
// *** Chapter Two ***
    
    /*
    function baz() {
        //call-stack is: baz
        //so, our call-site is in the global scope 
        
        console.log("baz");
        bar(); // <-- call-site for bar
    }
    
    function bar() {
        //call-stack is: baz -> bar
        //so our call-site is in baz
        
        console.log("bar");
        foo(); // <-- call-site for foo
    }
    
    function foo() {
        debugger;
        //call-stack is: baz -> bar -> foo
        //so our call-site is in bar
        
        console.log("foo");
    }
    
    baz(); // <-- call-site for baz
    
    
    
    //Default Binding
    
    function foo() {
        console.log(this.a);
    }
    
    var a = 2;
    
    foo(); //2
    
    
    //Implicit Binding
    
    function foo() {
        console.log( this. a );
        
    }
    
    var obj = {
        a: 2,
        foo: foo
    };
    
    obj.foo(); //2
    
    //Implicitly Lost
    
    function foo() {
        console.log(this.a);
    }
    
    var obj = {
        a: 2,
        foo: foo
    };
    
    var bar = obj.foo; //function reference/alias
    
    var a = "ops, global";
    
    bar(); // ops global
    
    
    //Explicit Binding
    
    function foo() {
        console.log( this.a );
    }
    
    var obj = {
        a: 2
    };
    
    foo.call( obj ); // 2
    
    //Harding Binding
    
    var bar = function() {
        foo.call( obj );
    }
    
    bar(); //2 
    bar.call( window ); //2
    
    function foo(a) {
        this.a = a;
    }
    
    var bar = new foo( 2 );
    console.log(bar.a); //2
    
    */
    //Everything in order
    
    //New Binding > Explicit Binding > Implicit Binding 

// *** Chapter Three ***
    /*
    
    
    var strPrimitive = "I am a string";
    typeof strPrimitive; //"string"
    strPrimitive instanceof String; // false 
    
    var strObject = new String("I am a string");
    typeof strObject; // "object"
    strObject instanceof String; //true
    
    //inspect the object sub-type
    Object.prototype.toString.call( strObject ); // [object String]
    
    
    
    //Property Descriptors
    
    var myObject = {   }
    
    Object.defineProperty( myObect, a, {
        value: 2,
        writable: true,
        configurable: true,
        enumerable: true
    } );
    
    
    //Immutability
    
        //Object Constant
    
    var myObject = {}
    Object.defineProperty( myObject, "FAVOURITE_NUMBER", {
        value: 42,
        writable: false,
        configurable: false,
    });
    
        //Prevent Extensions
    
    var myObject = {
        a:2
    };
    
    Object.preventExtensions( myObject );
    
    myObject.b = 3;
    myObject.b; //undefined
    
        //Seal
    Object.seal() calls Object.preventExtensions() on it, but marks
    all its existing properties as configurable:false.
        
        //Freeze
    Calls Object.seal() but also marks all properties as writable:false.
    Highest level of Immutability.

    // [[Get]]
    var myObject = {
        a: undefined
    };
    
    myObject.a; // undefined
    myObject.b; // undefined (but actually doesnt exist)
    
    //[[Put]]
    
    //Getters & Setters
    //Are properties which actually call a hidden
    //function to retrieve/set a value.
    
    var myObject = {
        //define a getter for a
        get a() {
            return 2;
        }
    }; 
    
    Object.defineProperty(
        myObject, //target
        "b", // property name
        {       // descriptor
            //define a getter for b
            get: function(){ return this.a * 2},
            
            //make sure b shows up as an object property
            enumerable: true
        }
    );
    
    myObject.a; // 2
    myObject.b; // 4
        
    
    var myObject = {
        // define a getter for 'a' 
        get a(){
            return this._a_;
        },
        
        //define a setter for 'a'
        set a(val) {
            this._a_ = val * 2;
        }
    };
    
    myObject.a = 2;
    myObject.a; // 4
    //Existence
    //Property acess like myObject.a may result in undefined if the value is either
    //undefined or if the a property doesn't exist at all
    
    var myObject = {
        a: 2
    };
    
    ("a" in myObject); // true
    
    myObject.hasOwnProperty("a"); // true
    
    
    //Enumeration
    //Enumerable basically means "will be included if the object's properties are iterated through"
    
    var myObject = { };

    Object.defineProperty(
        myObject,
        "a",
        // make `a` enumerable, as normal
        { enumerable: true, value: 2 }
    );

    Object.defineProperty(
        myObject,
        "b",
        // make `b` NON-enumerable
        { enumerable: false, value: 3 }
    );

    myObject.b; // 3
    ("b" in myObject); // true
    myObject.hasOwnProperty( "b" ); // true

    // .......

    for (var k in myObject) {
        console.log( k, myObject[k] );
    }
    // "a" 2
     
    //Another way to distinguish enumerable from non enumerable
    myObject.propertyIsEnumerable( "a" ); //true
    
    Object.keys(myObject); // ['a']
    Object.getOwnPropertyName( myObject ); // ["a", "b"]
    */
    //Iteration
    //the for .. in loop iterates only over the list of enumberable properties, not values
    //iterate over the values directly with for .. of
    
    var myArray = [1, 2, 3];
    
    for (var v of myArray){
        console.log(v);
    }
    
    var myArray = [ 1, 2, 3 ];
    var it = myArray[Symbol.iterator]();

    it.next(); // { value:1, done:false }
    it.next(); // { value:2, done:false }
    it.next(); // { value:3, done:false }
    it.next(); // { done:true }
    
    
    
    
    
    
</script> 
</body>
</html>